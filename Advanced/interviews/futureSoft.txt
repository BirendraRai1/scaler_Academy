1>What is event driven programming in nodejs?
https://www.geeksforgeeks.org/explain-event-driven-programming-in-node-js/
2>what is pyramid of doom in callback?
3>what is callback?
ans>Any function that is passed as an argument to another function 
so that it can be executed in that other function is called as a callback function
4>what are RESTfull api
ans>A REST API (also known as RESTful API) is an application programming interface (API or web API) 
that conforms to the constraints of REST architectural style and allows for interaction with RESTful web services. 
REST stands for representational state transfer.
REST APIs use the HTTP protocol to send and receive data
5>ð–ð¡ðšð­ ð¢ð¬ ð­ð¡ðž ðð¢ðŸðŸð«ðžð§ðœðž ð›ðžð­ð°ðžðžð§ ð©ðšcð¤ðšð ðž.ð£ð¬ð¨ð§ ðšð§ð ð©ðšcð¤ðšð ðž-ð¥ð¨ðœð¤.ð£ð¬ð¨ð§
ans>ð©ðšcð¤ðšð ðž.ð£ð¬ð¨ð§ : Developers manually edit this file to add or rename dependencies, modifies scripts. It records the minimum version your app needs.
    ð©ðšcð¤ðšð ðž-ð¥ð¨ðœð¤.ð£ð¬ð¨ð§ : It records the exact version of each installed package. It generally not meant to be manually edited, as it is managed automatically by npm
6>ð–ð¡ðšð­ ð¢ð¬ ð­ð¡ðž ðð¢ðŸðŸðžð«ðžð§ðœðž ð›ðžð­ð°ðžðžð§ ð…ð®ð§ðœð­ð¢ð¨ð§ ð’ð­ðšð­ðžð¦ðžð§ð­ ðšð§ð ð…ð®ð§ðœð­ð¢ð¨ð§ ð„ð±ð©ð«ðžð¬ð¬ð¢ð¨ð§ â“
ans>The major difference between function statement and function expression is ð‡ð¨ð¢ð¬ð­ð¢ð§ð .
âž¡ In case of ð…ð®ð§ðœð­ð¢ð¨ð§ ð’ð­ðšð­ðžð¦ðžð§ð­, we can call the function before declaration . During memory creation phase the function is allocated a memory and the whole function stored inside this.
âž¡ But in case of ð…ð®ð§ðœð­ð¢ð¨ð§ ð„ð±ð©ð«ðžð¬ð¬ð¢ð¨ð§, we can not call the function before declaration. During the memory creation phase the function is treated as any other variable. So the memory is allocated but it is assigned with ð®ð§ððžðŸð¢ð§ðžð. Thus this function is not accessible before execution of code.

ðŸ’¡ In the below code we are getting a ð“ð²ð©ðžð„ð«ð«ð¨ð« while calling b(). As we call b() before the function declaration for b, it leads to a ð“ð²ð©ðžð„ð«ð«ð¨ð« because at that point in the code, ð› ð¢ð¬ ð¬ð­ð¢ð¥ð¥ ð®ð§ððžðŸð¢ð§ðžð.

ðŸ“Œ If we declare the ð…ð®ð§ðœð­ð¢ð¨ð§ ð„ð±ð©ð«ðžð¬ð¬ð¢ð¨ð§ with ð¥ðžð­/ðœð¨ð§ð¬ð­ it leads to ð‘ðžðŸðžð«ðžð§ðœðžð„ð«ð«ð¨ð«. Because we know that due to ð“ðžð¦ð©ð¨ð«ðšð¥ ðƒðžðšð ð™ð¨ð§ðž we can not access let/const variable before initializes it with a value

7>ð‹ðžð­'ð¬ ðð¢ð¬ðœð®ð¬ð¬ ðš ðœð¨ð¦ð¦ð¨ð§ ð‰ð’ ðœð¡ðšð¥ð¥ðžð§ð ðž ð«ðžð¥ðšð­ðžð ð­ð¨ ð¬ðžð­ð“ð¢ð¦ðžð¨ð®ð­ + ðœð¥ð¨ð¬ð®ð«ðžð¬ : 
ans>function x(){
for(var i = 0; i <= 5; i++){
setTimeout(function(){
console.log(i);
}, i * 1000);
}
console.log("Hello JavaScript !")
}
x();

the expected output might be 1,2,3,4,5, each printed after each second. But the actual out will be 6 printed five times. Because -
âž¡ When the loop runs for the first time "setTimeout" takes the function and store it somewhere. Also the function remembers the reference of i.
âž¡ JS doesn't wait for anything. it will run this loop again and again, so the value of ð¢ ð›ðžðœðšð¦ðž ðŸ”.
âž¡ When the timer expired and the callback function runs , the value of i became 6 and it prints 6 every time.

ð‡ð¨ð° ð­ð¨ ðŸð¢ð± ð­ð¡ð¢ð¬ ð©ð«ð¨ð›ð¥ðžð¦:
âž¡ Use "let" over "var".
âž¡ Let has Block Scope, each time setTimeout runs, this callback function creates a ð§ðžð° ðœð¨ð©ð² ð¨ðŸ ð¢ ðšð§ð ðŸð¨ð«ð¦ð¬ ðœð¥ð¨ð¬ð®ð«ðž ð°ð¢ð­ð¡ ð¢ð­.
This is how the problem will be solved.

ð‡ð¨ð° ð­ð¨ ð¬ð¨ð¥ð¯ðž ð­ð¡ð¢ð¬ ð©ð«ð¨ð›ð¥ðžð¦ ð°ð¢ð­ð¡ð¨ð®ð­ ð®ð¬ð¢ð§ð  "ð¥ðžð­" :
âž¡By creating a closure.
âž¡ Create a function and enclose setTimeout within it.
âž¡ Call the function with i and pass i as an parameter inside the function.
âž¡ Every time we call the function it'll create a new copy of i. That's how the problem will be solved and we'll get the output 1 2 3 4 5